# For people around programmers

Having programmers in your life can be challenging. They're a strange bunch, keeping odd hours, telling jokes you don't understand, speaking what often seems a foreign language full of words that _sound_ English, maybe.

Their jargon is full of githubs and lusers and version control and 10 kinds of people and emacs and vim and console and hash tables and mongos and in-memory cloud services and … it gets pretty bad pretty quick. Even this book is full of such jargon because as a programmer I often forget I'm speaking jargon at all.

As such, the programmer community can seem impenetrable to the uninitiated. The fact it's dominated by human males with stellar egos and often terrible people skills doesn't make the situation any better. I don't know if other male dominated cultures are the same, but it's very common for a programmer to exclaim _"Oh my god, what idiot would code this!?"_ when looking through somebody else's work.

Only to realise a moment later it's their own code from a year ago. Oops.

We even have a website aimed specifically at making fun of people doing stupid things. The Daily WTF is a bit like our very own fail dot com.

But don't let this confuse you. Programmers are actually one of the most accepting bunch of people I have ever met. Where else could somebody tell an almost complete stranger that they're gay and the other person barely shrugging their shoulders?

San Francisco maybe.

Show a little interest in their craft and programmers will accept you as their own. Nobody will even notice you're a purple sea monster, they will just shower you with enthusiasm and try to teach you _everything_.

Very quickly. Very powerfully. Very overwhelmingly.

But it's a good kind of overwhelmed I hope. Programmers love to teach; just look at the plethora of personal blogs aimed at nothing more than having nerdgasms over a new hack somebody's discovered.

If there is but one thing you take away from this book, it should be that programmers are enthusiasts.

## Living with programmers

*"Sometimes I wake up in the middle of the night and there he is, still working. Still typing away at his codes even though he said he'd just be ten more minutes."*

*"Oh yeah that was just so you'd fall asleep easier."*

I was sitting on a plane with a friend and his girlfriend. Another five friends sat further up the low-budget airplane. Flying to a ten day surfing trip in Portugal we had eight laptops, eight smartphones, three or four tablets, and one kindle with us. Surf's up dude!

The time I didn't spend engrossed in Hemingway's adventures in Africa during the flight, I spent talking to my friend's girlfriend about what living with a programmer for the past four years has been. We'll call her Stacy because that isn't her name. She had plenty to say about arranging the small one-bedroom flat to give both enough space to work, how he always eats all the cookies, and who the only person who's allowed to get intimate with his computer is the kitten they found and kept two months ago. 

Reddit would say the cat was saved. Then she showed me a cute picture of a fluffy white thing using the guy's computer as a pillow while he looked intently at the screen and ignored the cat's presence.

But the comment that really stuck out to me was about going to bed in the evening.

Their bedroom doubles as his working space, their kitchen doubles as her working space. It might sound like the beginning of a sexist joke, but the arrangement works for them. I think it's because he needs an external monitor and there are more power outlets under the bedroom desk. Or maybe it's easier to resist eating all the cookies when you're not in the kitchen.

Either way, what often ends up happening is that Stacy wants to go to bed before her boyfriend is done working. Seeming as this is a happy relationship between two people in the midst of starting their careers - he just finished college and started a business, she just enrolled in a master's degree - it makes sense they'd go to bed together. It's what people who are in love do, right?

But that's not how it works when a programmer wants to finish something. It's "just ten more minutes" all the way down. As Stacy mentioned on the plane, she will often wake up in the middle of the night and see he's still coding away even though he said he'd be right in hours ago.

Sometimes he really thinks it's going to be just ten more minutes. These are the times when you feel the solution in your grasp and the more your each for it, the more it slips away. Find the problem, fix it, find out that wasn't the problem. And so on until it's suddenly light outside or you're so tired you can barely see what you're typing.

Other times it's far simpler. You want to work a few more hours in peace and quiet, but the other person keeps nagging you about wanting to go to bed and whether you will join them. So it's easier to say you're going to come to bed in ten minutes or half an hour and just wait for the other person to fall asleep.

I noticed a similar pattern when I was staying with my girlfriend for a week or two during renovations to my flat. Yes just for a week or two.

She's studying architecture, so just like me she needs a lot of space and alone time to get any real work done. Because we both work from home and only had the one room available this posed a great problem that wasn't made any easier when we discovered our work schedules are completely out of whack.

One thing we quickly discovered was that it's nearly impossible to work behind the same desk. While I could get a lot done simply because I'm more used to coworking, she found my presence very unnerving. Eventually we realized it's best if I am banned to the bean bag during weekends and off days because I don't need the extra monitor to read and write.

We never seem to have gone to bed together.

When it was her day to work, she would drag it out forever until I eventually gave up asking her to watch a movie with me and fell asleep. When I was working, she would always fall asleep several hours before I joined her in bed.

To focus and do real work, you need that quiet time when nobody is going to bother you. Preferably because they're busy, or even better if they're asleep.

I imagine the situation is much improved if you can have a home office and everyone knows when you're there it's Working Time™, but when your office doubles as everyone's bedroom concessions have to be made. One of which is making sure everyone else goes to bed earlier than you do.

That will buy the programmers at least a few hours of alone time.

But what about the people whose sleep is disturbed by somebody clacking away at the keyboard while they're trying to fall asleep?

Luckily, few people have trouble staying asleep once they've fallen asleep. Sleepy cycles are usually very long in the beginning of the night and once a person falls asleep they will not wake up for an hour or two no matter what you do to them. Even if they do wake up, they are not likely o remember the incident in the morning.

Another thing hat helps is turning off the lights because programmers don't really need light to work. Most can touch type and there's always enough light from the monitor to avoid spilling your drink. Good headphones make sure you can listen to music without bothering anyone else and are comfortable to boot.

### Surfing with 6 other programmers

When seven of my friends and I traveled to Portugal for ten days of sandy beaches, relaxed living, and surfing school, everyone brought their laptop. Everyone also had a smartphone and maybe a tablet or a GoPro.

Most of us brought work along as well. 

One guy didn't want to break his freelancing, another asked his boss to work remotely, two people focused on their schoolwork - one of them even defended homework via Skype - and one bloke kept pushing on his startup. I wanted to get a bunch of writing done. Only the academic and his boyfriend decided they'd actually relax all week.

One of them started reading a book because he never reads, the other tried setting the highest of high scores on Robot Unicorn Attack 2.

That's our idea of taking a week off to learn how to surf and have fun. Everyone with their own goals of stuffing as much as possible into the day when they aren't out there killing their chest and shoulders and pushing stamina to the max.

Maybe that's just how surfing works though. It's the sort of sport where you wake up in the morning and maybe you're going surfing. Or maybe you're waiting another three hours to go surfing. Or maybe you had to wake up really early to hit the waves at six in the morning.

But whatever you do, you won't be surfing after four or five in the afternoon at the latest. I'm not sure why that is, but I've never heard of an evening surfing session. Maybe something to do with tides?

Either way, surfing leaves you with a lot of free time when you're either too tired to surf, or conditions aren't right.

This plays right into how difficult it is for programmers to leave work behind when they go on vacation. Anywhere really.

After all, everything a programmer needs to work is a laptop, some time, and a decent internet connection. With forethought and good knowledge of their tools even the internet connection can be optional. Add to that the kind of work people get so engrossed with they forget to sleep, and you get a situation ripe for workaholism.

When our surf instructor picked us up from the airport and we told him how many laptops were in the van, he just shook his head in disbelief. You could see the *"Guys, you're here to surf and enjoy the outside. What do you need a laptop for?"* in his eyes.

The surf instructor is our complete opposite. Living the dream here in Portugal, surfing when he can, taking care of a surfer's hostel and teaching people from all over the world how to surf. Sounds like something people spend all their lives working towards, doesn't it?

Not us.

We just had to bring our own little slice of technology heaven with us. There's no telling what would happen to any of us if we didn't touch a keyboard for a few days. We'd probably shrivel up and die.

At the surf house, internet suddenly became the biggest problem known to man. With an average of two devices per person, the measly 3G router limited to five devices just couldn't cope. The situation improved somewhat when one of the guys found a piece of software that lets him share his wi-fi connection.

You cannot imagine the existential crisis people go through every time a website takes five minutes to load. The shared hotspot dropped every 90 minutes - we were too cheap to buy the full version of the software. Every time it happened, the house turned into a shrieking mess telling the guy to turn the internet back on.

Maybe not that bad, but there was definitely a lot of nervous foot tapping and angry glances.

If you were to walk into the living room when everybody's there, you'd be hard pressed to figure out we were spending quality time together as friends.

Dead silence. Cables strewn across the floor. People hanging off the sofas like it was a bus in India. Everyone holding on to their laptop for dear life, raising eyes off the screen only at the mention of food.

All other enquiries are met with a distracted ah-uh and a nod.

Despite the silence and lack of anything substantial going on, everyone complains they can't get any work done. That it's impossible to focus with all the commotion in the common area. Some of us have even skipped a surf session or two so we could get some focused work done.

Seems even programmers can't live together unless they have a lot of space to roam. I'm sure with time we could learn to live together in a tight space, but with eight people there will never be a time when everyone is trying to work at the same time.

Even if there was, I doubt we could feel productive with everyone invading each other's personal space. You can't work with someone looking over your shoulder, there's just too much pressure.

### Family

But how can a family incorporate someone so passionate about their craft they bring it along for vacation? Who needs so much space and distraction-free time to work?

Other than a few months here and there, I haven't lived with a programmer for extended periods of time yet. But having been programming since I was 9, I've got a lifetime of complaints behind me.

When I was a kid it was all about spending too much time behind the computer and not enough time doing other things. Now that I'm older it's all about spending too much time behind the computer and not enough time doing other things.

Nothing's really changed. Everyone I talked to when researching this book had basically that same complaint - programmers spend too much time at their computers and not enough time paying attention to things others think are important.

One woman I talked to said that living with a programmer takes a lot of sacrifice. Since he works from home, he's usually falling into the pattern of starting his days very late in the day. By the time she comes home, he's just gotten a good warmup and is deep in code.

She'd like to spend time with him, but he gets annoyed when she drags him out of flow kicking and screaming. It doesn't work.

Then she gets to work on her other stuff and by the time he's ready to spend time with her, she's the one deep in flow. That doesn't work either.

The result is they started talking to each other mostly via chat because it's easy and it's always there when you're at the computer. Because it's asynchronous you can tell the other person something non-urgent and they will read it and respond when they get a free moment.

It works, but feels impersonal. When others hear you're doing this, they will think the practice is dysfunctional and might become worried about the state of your relationship. It's difficult to say whether they're right or wrong.

I would suggest spending as much face-to-face time as possible. The world is littered with stories of relationships falling apart because one person was too deep in their craft. Watch any movie about a famous rock star or writer or successful whatever, I promise at least one relationship will fall apart along the way.

The solution is mutual understanding and making an effort. Don't bother your programmer when they're working, and they will reward you with the same devoted level of attention as soon as that thing that's tugging at their brain goes away. And always keep in mind that when a programmer looks absent and distant-minded, they're usually not worrying about you. It's about that bug.

Ask them about it. Be the ducky they can explain the problem to and it won't matter whether you understand or not, it will help them find the solution.

For instance, a guy I talked to said marrying a programmer was like winning the lottery. Exactly because he doesn't have to leave work at work. They can help each other solve difficult problems and talking about cool algorithms is never out of the question.

But you don't have to understand everything perfectly. Just keep an open mind and always encourage your programmer to talk about their craft. Even if you don't understand, it will mean the world to them that you care to listen.

## Working with programmers

The greatest challenge of working with programmers is having two people working closely together on a single project. Probably sitting close by they are the best source of interruption for each other.

Imagine you are one of the two. Getting up to grab some coffee, do you ask the other person if they want some as well? When hitting a snag, do you ask them a question immediately or wait until a good moment? Noticing a magnificently hilarious cat picture, do you tell them? Share it immediately or send an email, or keep it to yourself?

The answer to these questions will define how great you are to work with.

### How interruptions spread

There is a team of programmers working together in an office. Deep in thought, code effortlessly flowing from their fingertips, one of them suddenly hits a snag. It happens because a related piece of code designed by another programmer is behaving in unexpected ways. 

Unable to resolve the issue themselves they are violently thrown out of flow. Snapped back into reality our programmer looks around the office in dazed confusion. Will somebody notice their plight? Will somebody volunteer a helping _"What's the problem? Can I help?"_, or is everyone too deep in their own mess to notice?

One of two things is going to happen next.

1. Nothing else to work on, no desire for some creative procrastination, the developer musters the courage to ask a question _now_. They walk up to the person they reckon could help and ask them a question. Now both developers are out of flow.

2. The other likely possibility isn't much better. The developer first arses about on the internet for a while, hoping this will jog their brain and produce a bit of inspiration. It doesn't work. They get up for a walk - somewhere deep in the recesses of their mind a small voice is saying they need to stretch their legs. Another developer notices activity out of the corner of their eye and decides it's time for a break. Now both developers are out of flow.

There are infinite variations on these two courses of events, but they all result in the same thing. Two interrupted developers who will take half an hour at least to get back in flow.

But now the interruption is gaining momentum. It will spread person to person until everyone in the office is out of flow. As the group becomes louder and more chaotic so its interruptive potential grows. Each new member also adds another connective point for interrupting somebody else.

Of course there is also a dampening effect so the smaller and more personally connected the team, the likelier it is all of it will be affected by an interruption.

These events are inevitable, what's important is how far they are allowed to spread and whether they are productive in solving the problem that started them. A certain number of productive interruptions is healthy, even necessary, too many can kill everyone's productivity.

### Communication

For most software projects communication is vital. I'd say _all_ software projects, but hanging out with theoretical computer scientists has made me wary of infinity.

Different communication styles fit different parts of the project. While face-to-face meetings might work best to eke requirements out of clients, instant messaging often works best for software teams to avoid interrupting one another.

Having just the right amount of communication so things run smoothly and developers still have enough time to work is an art that takes most people a few years to develop. Some never get there and the internet is full of programmers complaining about co-workers and pointy-haired bosses.

Programmers hate meetings and with good reason.

#### Meetings

Meetings are the best example of a culture clash between people on the maker's schedule and those on the manager's schedule. For a manager, the meeting takes an hour and after a quick break they'll be ready for the next item on their agenda. In terms of time the meeting is free, not only that, it's exactly what they are paid to do and likely represents the best use of company assets.

At least a productive meeting does.

For a programmer the story is different. A single poorly timed meeting can kill an afternoon, sometimes even a day. It takes a while to get back to work and the effort might not be worth it, if there aren't going to be a few hours of empty time before day's end or the next meeting. Another half hour is easily killed before the meeting even begins if the developer reaches a natural stopping point and an imminent meeting means there's no sense in continuing with the next task.

Sure, it's important for programmers to pass know-how between one another and they should definitely be kept in the loop about project objectives, but a meeting is almost never the most productive use of a programmer's time. Especially considering a one hour meeting can easily take three hours of a developer's time.

At $50 an hour a one hour meeting between two programmers is worth $300 in time. Keep that in mind the next time you want to call a meeting, especially if a simple email would do.

Even deciding that a meeting is in fact worth everybody's time, there are other issues making meetings less than ideal.

When people can't go to meetings in person due to geographical constraints, we resort to Skype or similar technology - I hear a lot of people still use telephones, even if mostly for one-on-one conversations.

But participation in a dynamic meeting when you aren't really there is difficult at best. 

Your field of view is narrow, sounds escape the mic, crappy internet connections can make your words choppy or keep you a few seconds behind everybody else. What's worse, even modern means of real-time communication can't solve scheduling conflicts.

And yet, it’s important for everybody to know what happened in the meeting. Add the fact that human memory is fallible and you have a situation where even the people who were there will soon forget what went on.

Meeting minutes will solve the problem for everyone to an extent. Those not present will get to know the main takeaways of the meeting and even after a while everyone will still know the decisions that were made. But the minutes don't capture everything that happens in meetings. 

Conversations race ahead of the person taking notes, they diverge in many directions and often run in circles. Even if the minutes were perfect, they would be boring and difficult to follow. Small teams in particular tend to just write down some notes instead of detailed minutes.

#### Asynchronous communication

Communicating primarily through email or issue tracking systems can solve these problems completely. What you lose in throwing away nonverbal cues, you gain in the perfect logging of conversations and decision making processes.

More importantly, a well written email or issue ticket is much better at conveying information than the muddled real-time thought flow we see in verbal communication. People _think_ before writing.

Perhaps this is a cultural thing, but I have rarely seen people take some time to think through what they are about to say. There is an impetus to avoid pauses lest you seem "slow". To think out loud instead of providing complete answers. This is often a good thing, it lets everyone in on your thoughts, avoids any chance to pad out the painful truth with niceties.

Thinking out loud can also cause problems when a stream of half thoughts makes it difficult to pick out a good solution. Conversations become difficult to follow, especially in notes, and having quick loud thinkers mix with those wanting to think before they speak, can easily ensure the latter never get any air time at all.

As engineers usually have a low tolerance for bullshit and half-baked answers the most valuable input will often not be heard. Not only that, listening to other’s half baked ideas will make many an engineer feel like their time is being wasted.

Another thing emails solve well is group yak shaving.

This happens when somebody raises a tangential point that piques everybody's interest. Before you know it an architecture design meeting devolves into discussing an implementation detail of a soon to be discarded feature.

It feels productive, everyone is learning, but it gets in the way of solving the issue at hand.

When this happens while writing an email I will often cut it out after developing my thought and realising it adds nothing to the overall message. That would be 10 minutes of a meeting wasted.

Sometimes I decide I don't even have to send the email anymore. Just thinking through a problem enough to explain to somebody can solve it for me.

Also, don't underestimate the benefits of reading and rereading a complex bit of technical info until understanding is reached. Talking in person means the other person needs to repeat what they've said multiple times.

This depends of course on the teaching skills of the other person, sometimes they can munge their explanation so everyone understands.

### Taking advantage of interruptions

No matter how much you try to avoid it, sometimes a combination of email, instant messaging and issue tracking systems just will not do. You have to speak to somebody in person.

However, the general motto still stands, unless people are dying - and they rarely are - you should respect a person's time. Being interrupted while working can create a big mess, so just don't. You wouldn't want somebody interrupting you in the middle of, say, a phone call, would you?

So what are you to do?

Take advantage of naturally occurring interruptions. They also happen to be the easiest to deal with in terms of keeping mental context intact.

Let's say you work in a team that does daily standup meetings to keep tabs on who is doing what and whether anyone has hit a problem and needs some help. This is a ten minute meeting that you can schedule, making it into a half hour distraction or more.

A better approach is to avoid scheduling anything shorter than half an hour at all. When the last person on the team comes into the office they will interrupt everyone by greeting them. Since it's a positive interruption and such a minor one at that nobody will mind. Many won't even break stride in their work!

Now is a great time to have that quick ten minute meeting.

"Daily standup" is a horrible buzz word anyway. It used to be called "Having a cup of coffee with my coworkers every morning". You wouldn't do bad to keep that in mind and treat it as such.

### Batch processing

Another good habit to build when working with programmers and other creatives is batch processing. When you have something to ask, an idea to clear, or anything really, don't giddily rush off and interrupt somebody.

Collect your questions and ideas. Write them down on a post-it note, in a notebook or in an email. When you feel there's enough, wait for a good moment and ask the person for an extended moment of their time.

Programming is fraught with natural stopping points.

When you finish a function. When you write some tests. When you run a full test suite. When you press compile. When you finish a feature. When you pinpoint the code where a bug is hiding. When you …

This is programming's curse. This is why programmers often get sucked into the vortex of online discussion wasting more time than they would like. But it's also a blessing because it gives their colleagues many opportunities to interrupt without actually interrupting.

When a programmer has reached a natural stopping point in their work they are naturally inclined to take a little break. Not only do they need to think for a bit before moving on to the next granular task on their list, but the feeling of having just finished something, no matter how small, makes a person want to sit back and bask in the glory.

Now is the time to step in and go through the batch of problems you need help with. It's also very likely that any email you may have sent will be answered at such an occasion.

The problem, then, is spotting a programmer who is between steps.

The simplest way is to leave the decision up to them, send an email, wait for them to answer when the time is right. However, this is fraught with worry whether they noticed the email, how diligent they are with responding to everyone and a bunch of other little problems that mostly have to do with trust.

By the way, do try to clean out your inbox at least once a day. As a courtesy to everyone who respects your time enough to avoid bothering you directly.

Another great approach is to look for signs of procrastination and general time wasting. Is the focus on a twitter client? Are they looking at a browser and it isn't documentation? Playing office warfare or spinning in their chair? Perhaps just getting up for a cup of tea?

That's your cue. Pounce.

One thing to keep in mind is fitting everything inside this natural stopping point zone. I find anything that will take longer than five minutes needs to be scheduled off into the far distance. Usually at the end of the work day or in that half hour after lunch when I'm putting off getting back to work.

Don't try to fit anything "hard" in those five minutes either. Where hard is defined as anything that requires thinking deeply about something other than whatever the programmer was doing before. Simple things are okay, helping you with a bug is not.

### It will take just five minutes

Coworkers often don't understand how long it takes to code something. Non-technical people especially, but programmers are just as guilty.

Just the other day I was talking with a mate on Skype who complained that his boss will often egg him on to add just one little thing. _"Come on, it's only going to take five minutes, you can add it."_

Despite trying his best to resist these small tweaks, he usually breaks down and adds it anyway. This happens partly because programmers in general are less skilled negotiators than managers whose job is mostly negotiation. There's also a power dynamic at play - it's usually difficult to deny a boss's request.

But more importantly, it's very difficult to make a logical case that X is _not_ a five minute job. Of course you can add a small button to a webpage in five minutes. Ten minutes tops. It's no more than a line of code. How could such a small piece of the puzzle possibly take more than five minutes?

Exactly because it's a piece of the puzzle.

When systems grow the complexity no longer lies in individual pieces but in the system as a whole. For a programmer to add a small five minute feature they have to first consider the whole system.

Does the system support adding that one feature? Will I have to bolt this on as an ugly hack to make it work? How many things need to be redesigned to make this feasible?

When all of that is considered, it takes at least five minutes to spin up the development environment. You have to open a text editor, something to test your code and so on. As a web developer I usually have at least one Emacs and one Chrome windows open.

Then you have to find the right file to implement the feature in. Because your system has grown so much you can rarely implement a tiny button using a single file. The button goes in one file, its styling in another, then there's a file for making the button actionable and often a fourth file for the text.

Each of those files will be several hundred lines long and you have to find the right place for new code in each file, consider what other code you can reuse and whether any existing code needs to change to accommodate the new feature. Even the best mental map of the files and search technique will not save you from reading a few dozens lines of code. 

Scanning through some 1500 words (counting important code symbols as words and assuming an average of 20 per line) takes time. You can read about 300 words per minute on average, which means you are going to spend five minutes reading code before you even get to implementing your five minute feature.

Now that the programmer has spent at least ten minutes implementing that quick fix it's time to test. Which means a round of writing tests or clicking around the interface. Usually both.

After twenty or so minutes have passed that quick five minute job is done.

Now they have to keep supporting it for the rest of the product's life cycle. This means keeping it in mind next time a small feature is implemented, making sure it works when surrounding code changes and keeping the user experience consistent.

That five minute quick feature will take _hours_ of developer time over the next few months or years.